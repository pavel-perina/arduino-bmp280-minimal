#!/usr/bin/env python3
import struct

# Generated by Claude AI from C++ code

class Calibration:
   def __init__(self, T1=0, T2=0, T3=0, P1=0, P2=0, P3=0, P4=0, P5=0, P6=0, P7=0, P8=0, P9=0, H1=0):
       self.T1 = T1
       self.T2 = T2
       self.T3 = T3
       self.P1 = P1
       self.P2 = P2
       self.P3 = P3
       self.P4 = P4
       self.P5 = P5
       self.P6 = P6
       self.P7 = P7
       self.P8 = P8
       self.P9 = P9
       self.H1 = H1

class Measurement:
    def __init__(self):
        self.pressure: float = 0.0
        self.temp: float = 0.0
        self.humidity: float = 0.0

def decode_20bit(data: bytes) -> int:
    return (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)

def decode_calibration(cal_data: bytes) -> Calibration:
    # Format: <HHHHHHHHHHHH
    # < = little endian, H = uint16
    values = struct.unpack('<HHHHHHHHHHHH', cal_data[:24])
    return Calibration(
        T1=values[0],
        T2=struct.unpack('<h', struct.pack('<H', values[1]))[0],  # Convert to signed
        T3=struct.unpack('<h', struct.pack('<H', values[2]))[0],
        P1=values[3],
        P2=struct.unpack('<h', struct.pack('<H', values[4]))[0],
        P3=struct.unpack('<h', struct.pack('<H', values[5]))[0],
        P4=struct.unpack('<h', struct.pack('<H', values[6]))[0],
        P5=struct.unpack('<h', struct.pack('<H', values[7]))[0],
        P6=struct.unpack('<h', struct.pack('<H', values[8]))[0],
        P7=struct.unpack('<h', struct.pack('<H', values[9]))[0],
        P8=struct.unpack('<h', struct.pack('<H', values[10]))[0],
        P9=struct.unpack('<h', struct.pack('<H', values[11]))[0],
        H1=cal_data[25]
    )

def decode(calibration: bytes, measurement: bytes) -> Measurement:
    result = Measurement()
    dig = decode_calibration(calibration)
    
    # Temperature
    temp_raw = decode_20bit(measurement[3:6])
    var1 = ((temp_raw >> 3) - (dig.T1 << 1)) * dig.T2 >> 11
    var2 = (((temp_raw >> 4) - dig.T1) * ((temp_raw >> 4) - dig.T1) >> 12) * dig.T3 >> 14
    t_fine = var1 + var2
    T = (t_fine * 5 + 128) >> 8
    result.temp = T / 100.0

    # Pressure
    adc_P = decode_20bit(measurement[0:3])
    var1 = t_fine - 128000
    var2 = var1 * var1 * dig.P6
    var2 = var2 + ((var1 * dig.P5) << 17)
    var2 = var2 + (dig.P4 << 35)
    var1 = ((var1 * var1 * dig.P3) >> 8) + ((var1 * dig.P2) << 12)
    var1 = ((1 << 47) + var1) * dig.P1 >> 33
    
    if var1 != 0:
        p = 1048576 - adc_P
        p = ((p << 31) - var2) * 3125 // var1
        var1 = (dig.P9 * (p >> 13) * (p >> 13)) >> 25
        var2 = (dig.P8 * p) >> 19
        p = ((p + var1 + var2) >> 8) + (dig.P7 << 4)
        result.pressure = p / 256.0

    return result

# Test data
calibration = bytes([
    0x36, 0x6C, 0x05, 0x68, 0x18, 0xFC, 0xA1, 0x8D,
    0x93, 0xD6, 0xD0, 0x0B, 0xC3, 0x06, 0x3B, 0x01,
    0xF9, 0xFF, 0x8C, 0x3C, 0xF8, 0xC6, 0x70, 0x17,
    0x00, 0x00
])

measurement = bytes([
    0x6C, 0x07, 0x00, 0x7E, 0x4C, 0x00, 0x00, 0x00
])

if __name__ == "__main__":
    m = decode(calibration, measurement)
    print(f"Pressure: {m.pressure:.1f}Pa, Temperature: {m.temp:.2f}C, Humidity: {m.humidity}")

